<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galton Board Simulator</title>
    <link rel="stylesheet" href="the.css">
    <link rel="stylesheet" href="lib/tsm.css">
    
    <!-- TSM Design System Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Poppins:wght@600;700;800&display=swap" rel="stylesheet">
    
    <!-- Firebase -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    
    <style>
        :root {
            /* TSM Design System Colors */
            --tsm-blue: #005EE9;
            --tsm-blue-hover: #0067FF;
            --tsm-blue-dark: #0051c9;
            --background: #F7F9FC;
            --foreground: #0F172A;
            --gray-50: #f8fafc;
            --gray-100: #f3f4f6;
            --gray-200: #e5e7eb;
            --gray-300: #d1d5db;
            --gray-400: #cbd5e1;
            --gray-500: #64748b;
            --gray-600: #475569;
            --gray-700: #334155;
            --gray-800: #1e293b;
            --border-color: #e2e8f0;
            --white: #ffffff;
            --info-bg: #F3F7FE;
            --info-border: #bae6fd;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--background);
            color: var(--foreground);
            font-size: 16px;
            line-height: 1.5;
            margin: 0;
            padding: 0;
        }
        
        h1, h2, h3, h4, h5, h6 {
            font-family: 'Poppins', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        
        .app-container {
            background: var(--background);
            min-height: 100vh;
        }
        
        /* Header */
        .header {
            background: #0051c9;
            color: white;
            padding: 1.5rem 2rem;
        }
        
        .header-content {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .back-button {
            background: transparent;
            border: none;
            color: #ffffff;
            padding: 8px 12px;
            border-radius: 0.375rem;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            font-size: 14px;
            margin-bottom: 1.5rem;
            transition: background-color 0.2s;
            text-decoration: none;
        }
        
        .back-button:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .header-info {
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            position: relative;
        }
        
        .header-icon {
            background: rgba(255, 255, 255, 0.2);
            padding: 0.75rem;
            border-radius: 0.75rem;
            flex-shrink: 0;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        
        .header-text h1 {
            font-family: 'Poppins', sans-serif;
            font-size: 1.875rem;
            font-weight: 700;
            margin: 0 0 0.5rem 0;
            color: white;
        }
        
        .header-text p {
            color: white;
            opacity: 0.9;
            font-size: 1rem;
            line-height: 1.6;
            margin: 0;
        }
        
        .header-version {
            position: absolute;
            top: 0;
            right: 0;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.7);
            display: flex;
            align-items: center;
            gap: 0.375rem;
        }
        
        .version-separator {
            color: rgba(255, 255, 255, 0.5);
        }
        
        /* Info Banner */
        .info-banner {
            background: #F3F7FE;
            border: 1px solid #bae6fd;
            border-radius: 0.75rem;
            padding: 12px 16px;
            display: flex;
            gap: 0.75rem;
            width: 1216px;
            min-height: 90px;
            margin: 32px auto;
            align-items: flex-start;
            max-width: calc(100% - 64px);
        }
        
        .info-icon {
            color: #005EE9;
            flex-shrink: 0;
            margin-top: 0.125rem;
        }
        
        .info-content {
            color: #64748b;
            font-size: 0.875rem;
        }
        
        .info-content strong {
            display: block;
            margin-bottom: 0.25rem;
            color: #64748b;
            font-weight: 600;
        }
        
        .info-content p {
            margin: 0;
            color: #64748b;
            font-size: 0.875rem;
        }
        
        /* Content Layout */
        .main-content {
            padding: 48px 32px;
        }
        
        .content-wrapper {
            display: grid;
            grid-template-columns: minmax(0, 35%) minmax(0, 1fr);
            gap: 2rem;
            width: 1216px;
            max-width: 100%;
            margin: 0 auto;
            padding: 0 0 2rem 0;
        }
        
        .left-panel {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }
        
        .right-panel {
            display: flex;
            flex-direction: column;
            gap: 2rem;
        }
        
        /* Segmented Control */
        .segmented {
            display: flex;
            gap: 0.25rem;
            background: #e5e7eb;
            border-radius: 0.75rem;
            padding: 0.25rem;
            margin-top: 0.5rem;
        }
        
        .segment {
            flex: 1;
            background: none;
            border: none;
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            color: #64748b;
            cursor: pointer;
            transition: none; /* avoid any delayed visual change */
        }
        
        .segment:hover:not(.active) {
            color: #1e293b;
        }
        
        .segment.active {
            background: #ffffff !important;
            color: #1e293b !important;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1) !important;
        }

        /* Ensure immediate feedback on press */
        .segmented .segment:active {
            background: #ffffff !important;
            color: #1e293b !important;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1) !important;
        }

        /* Also apply immediate white on focus, and remove default outline */
        .segmented .segment:focus {
            background: #ffffff !important;
            color: #1e293b !important;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1) !important;
            outline: none !important;
        }

        /* Force-disable hover effect on Drop Mode toggle */
        .segmented .segment:hover {
            background: none !important;
            color: inherit !important;
            font-weight: inherit !important;
            box-shadow: none !important;
        }
        /* Ensure active hover cannot override white */
        .segmented .segment.active:hover {
            background: #ffffff !important;
            color: #1e293b !important;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1) !important;
        }
        
        /* Section Cards */
        .section {
            background: #ffffff;
            border: 2px solid #3b82f6;
            border-radius: 0.75rem;
            padding: 1.5rem;
        }
        
        /* Results Card - exact from template */
        .results-card {
            background: white;
            border-width: 2px;
            border-style: solid;
            border-color: rgb(59, 130, 246) !important;
            border-image: initial;
            border-radius: 1rem;
            overflow: hidden;
        }
        
        .results-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: #eff6ff;
            padding: 1.5rem 1.5rem 0 1.5rem;
            margin: -1.5rem -1.5rem 0 -1.5rem;
        }
        
        .results-card h3 {
            font-size: 1.5rem;
            font-weight: 700;
            color: #2563eb;
            margin: 0;
            background: transparent;
            padding: 0;
        }
        
        .results-subtitle {
            color: #64748b;
            font-size: 0.875rem;
            margin-top: 0;
            margin-bottom: 2rem;
            background: #eff6ff;
            padding: 0 1.5rem 0.5rem 1.5rem;
            margin-left: -1.5rem;
            margin-right: -1.5rem;
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .result-item {
            text-align: center;
            background: #F7F9FC;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid #E2E8F0;
        }
        
        .result-value {
            font-size: 2.25rem;
            font-weight: 500;
            color: #005EE9;
            margin-bottom: 0.5rem;
            line-height: 1;
        }
        
        .result-value.purple {
            color: #7c3aed;
        }
        
        .result-value.effect {
            color: #f97316;
        }
        
        .result-label {
            font-size: 0.875rem;
            color: #64748b;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
        }
        
        .section h3 {
            font-family: 'Poppins', sans-serif;
            font-size: 1.125rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
            color: #0F172A;
        }
        
        .section-subtitle {
            font-family: 'Inter', sans-serif;
            font-weight: 400;
            font-size: 1rem;
            line-height: 1.5rem;
            color: #64748b;
            margin-bottom: 1.5rem;
        }
        
        /* Form Elements */
        .form-group {
            margin-bottom: 1.5rem;
        }
        
        .form-group:last-child {
            margin-bottom: 0;
        }
        
        .form-group label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 500;
            margin-bottom: 0.5rem;
            font-size: 0.875rem;
            color: #0F172A;
        }
        
        /* Buttons */
        .btn-primary-custom {
            background: linear-gradient(135deg, #005EE9, #0067FF);
            color: white;
            border: none;
            padding: 0.875rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            font-size: 1rem;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            width: 100%;
        }
        
        .btn-primary-custom:hover {
            background: linear-gradient(135deg, #0051c9, #005EE9);
            box-shadow: 0 2px 4px rgba(0, 94, 233, 0.2);
        }
        
        .btn-primary-custom:active {
            transform: translateY(0);
        }
        
        .btn-secondary-custom {
            background: #f3f4f6;
            color: #475569;
            border: 1px solid #d1d5db;
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            font-weight: 500;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }
        
        .btn-secondary-custom:hover {
            background: #e5e7eb;
            border-color: #9ca3af;
        }
        
        .btn-secondary-custom:active {
            background: #d1d5db;
        }
        
        .btn-outline-custom {
            background: transparent;
            color: #64748b;
            border: 1px solid #e2e8f0;
            padding: 0.75rem 1.25rem;
            border-radius: 0.5rem;
            font-weight: 500;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }
        
        .btn-outline-custom:hover {
            background: #f8fafc;
            border-color: #cbd5e1;
            color: #334155;
        }
        
        .clear-button {
            background: transparent;
            border: 1px solid #e2e8f0;
            color: #64748b;
            padding: 0.5rem 0.875rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .clear-button:hover {
            background: #f8fafc;
            border-color: #cbd5e1;
            color: #334155;
        }
        
        /* Slider */
        .slider-group {
            margin-bottom: 1.5rem;
        }
        
        .slider-group:last-child {
            margin-bottom: 0;
        }
        
        .slider-label {
            display: flex;
            align-items: center;
            margin-bottom: 0.5rem;
            gap: 0.25rem;
        }
        
        .slider-label label {
            font-weight: 500;
            color: #0F172A;
            font-size: 0.875rem;
            line-height: 1;
        }
        
        .slider-controls {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .slider-btn {
            width: 28px;
            height: 28px;
            border: 1px solid #cbd5e1;
            background: white;
            border-radius: 0.375rem;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            color: #64748b;
            transition: all 0.2s;
            flex-shrink: 0;
        }
        
        .slider-btn:hover {
            background: #f8fafc;
            border-color: #94a3b8;
            color: #334155;
        }
        
        .slider-btn:active {
            background: #f1f5f9;
        }
        
        .slider-value {
            font-weight: 600;
            color: white;
            background: #005EE9;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            width: 48px;
            height: 26px;
            text-align: center;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .slider-value.orange {
            background: #f97316;
        }
        
        input[type="range"] {
            flex: 1;
            height: 6px;
            background: #005EE9;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: white;
            border: 3px solid #005EE9;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: white;
            border: 3px solid #005EE9;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.1);
        }
        
        /* Chart Section - absolutely NO border, NO radius, NO background */
        .chart-section,
        .results-card .chart-section,
        div.chart-section {
            background: none !important;
            border: 0 !important;
            border-radius: 0 !important;
            padding: 0 !important;
            margin-top: 1.5rem !important;
            box-shadow: none !important;
            outline: none !important;
        }
        
        .chart-section h4 {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0;
        }
        
        .chart-header {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            margin-bottom: 0.5rem;
            flex-wrap: wrap;
        }
        
        .chart-legend {
            display: flex;
            align-items: center;
            gap: 1.5rem;
            margin-bottom: 0;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
        }
        
        .curve-style-controls {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-left: auto;
        }
        
        .curve-control-label {
            font-size: 0.75rem;
            color: #64748b;
            font-weight: 500;
        }
        
        .curve-control-select {
            padding: 0.375rem 0.625rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            font-size: 0.75rem;
            background: #ffffff;
            cursor: pointer;
            color: #475569;
            font-weight: 500;
            min-width: 128px;
        }
        
        .curve-control-select:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }
        
        .curve-control-select:hover {
            border-color: #cbd5e1;
        }
        
        .curve-control-label {
            font-size: 0.75rem;
            color: #64748b;
            font-weight: 500;
        }
        
        .curve-control-select {
            padding: 0.375rem 0.625rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            font-size: 0.75rem;
            background: #ffffff;
            cursor: pointer;
            color: #475569;
            font-weight: 500;
            min-width: 128px;
        }
        
        .curve-control-select:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }
        
        .curve-control-select:hover {
            border-color: #cbd5e1;
        }
        
        /* Canvas - exact from template */
        .chart-container {
            background: white;
            border: 2px solid #cbd5e1;
            border-radius: 0;
            padding: 0;
            margin-bottom: 1rem;
            width: 100%;
            overflow: visible;
            position: relative;
            z-index: 3;
        }
        
        .chart-container canvas {
            width: 100%;
            max-width: 800px;
            height: auto;
            display: block;
            border: none;
            background: #ffffff;
            margin: 0 auto;
        }
        
        /* Unified canvas: no external border; seamless look */
        .unified-box canvas {
            border: none;
        }
        
        /* Histogram */
        .histogram-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .histogram-legend {
            display: flex;
            gap: 1rem;
            font-size: 0.875rem;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .legend-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }
        
        .legend-dot.actual {
            background: linear-gradient(135deg, #3b82f6, #60a5fa);
        }
        
        .legend-dot.theoretical {
            border: 2px solid #f59e0b;
            background: transparent;
        }

        /* Tailwind Toggle Switch */
        .toggle-container {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0;
            flex-wrap: nowrap;
        }

        /* Two-column grid for visualization toggles */
        .toggle-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            column-gap: 1rem;
            row-gap: 0.25rem;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 36px;
            height: 20px;
            flex-shrink: 0;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #d1d5db;
            transition: 0.3s;
            border-radius: 24px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 2px;
            bottom: 2px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: #7C3AED;
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(16px);
        }
        
        .toggle-label {
            font-size: 0.875rem;
            color: #0F172A;
            font-weight: 500;
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
        }
        
        /* Info Button */
        .info-button {
            background: none !important;
            border: none;
            padding: 0;
            cursor: pointer;
            color: #64748b !important;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-left: 0;
            transition: none !important;
            line-height: 1;
            position: relative;
            top: -5px;
        }
        
        .info-button:hover,
        .info-button:focus,
        .info-button:active {
            background: none !important;
            color: #64748b !important;
            opacity: 1 !important;
            transform: none !important;
        }
        
        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            animation: fadeIn 0.2s ease-in-out;
        }
        
        .modal.active {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(2px);
        }
        
        .modal-container {
            position: relative;
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            animation: slideUp 0.3s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }
        
        .modal-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1.5rem;
            border-bottom: 1px solid #E2E8F0;
            background: #F7F9FC;
        }
        
        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1E293B;
            margin: 0;
        }
        
        .modal-close {
            background: none;
            border: none;
            padding: 0.5rem;
            cursor: pointer;
            color: #64748B;
            transition: all 0.2s;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .modal-close:hover {
            background: #E2E8F0;
            color: #1E293B;
        }
        
        .modal-body {
            padding: 1.5rem;
            overflow-y: auto;
            max-height: calc(80vh - 80px);
        }
        
        .modal-body p {
            margin: 0;
            line-height: 1.6;
            color: #475569;
            font-size: 0.9375rem;
        }
        
        /* Stats */
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 0;
            border-bottom: 1px solid #f3f4f6;
        }
        
        .stat-row:last-child {
            border-bottom: none;
        }
        
        .stat-row:first-child {
            padding-top: 0;
        }
        
        .stat-label {
            font-weight: 500;
            color: #0F172A;
            font-size: 0.875rem;
            line-height: 1;
        }
        
        .stat-value {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .badge {
            padding: 0;
            background: #005EE9;
            color: white;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 600;
            width: 72px;
            height: 26px;
            text-align: center;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .percentage {
            color: #64748b;
            font-size: 0.875rem;
        }
        

        
        /* Footer */
        .app-footer {
            background: white;
            border-top: 1px solid #e2e8f0;
            padding: 1.5rem 2rem;
            margin-top: 3rem;
        }
        
        .footer-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.875rem;
            color: #64748b;
            flex-wrap: wrap;
            gap: 1rem;
        }
        
        .footer-left, .footer-right {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .footer-brand {
            font-weight: 600;
            color: #0F172A;
        }
        
        .footer-separator {
            color: #cbd5e1;
        }
        
        .footer-link {
            color: #005EE9;
            text-decoration: none;
            transition: color 0.2s;
        }
        
        .footer-link:hover {
            color: #0067FF;
            text-decoration: underline;
        }
        
        /* Theme Selector */
        .theme-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            z-index: 10;
        }
        
        .theme-label {
            font-size: 0.875rem;
            color: #64748b;
            font-weight: 500;
        }
        
        .theme-select {
            padding: 0.375rem 0.75rem;
            border: 1px solid #e5e7eb;
            border-radius: 0.5rem;
            background: white;
            color: #0F172A;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .theme-select:hover {
            border-color: #005EE9;
        }
        
        .theme-select:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }

        /* Canvas toolbar */
        .canvas-toolbar {
            pointer-events: auto;
        }
        .canvas-toolbar .clear-button {
            background: #ffffff;
            border-color: #e2e8f0;
        }
        .canvas-toolbar .clear-button:hover {
            background: #f8fafc;
            border-color: #cbd5e1;
        }
        .canvas-toolbar .menu-item:hover {
            background: #f8fafc;
        }
        
        @media (max-width: 1280px) {
            .content-wrapper {
                width: 100%;
                grid-template-columns: 1fr;
            }
        }
        
        @media (max-width: 768px) {
            .header {
                padding: 1rem 1.5rem;
            }
            
            .header-text h1 {
                font-size: 1.5rem;
            }
            
            .header-version {
                position: static;
                margin-top: 0.5rem;
            }
            
            .main-content {
                padding: 24px 16px;
            }
        }
    </style>
</head>
<body>
  <div class="app-container">
    <!-- Header -->
    <header class="header">
      <div class="header-content">
        <a href="index.html" class="back-button">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
            <path d="M10 12L6 8L10 4" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
          Back to Demonstrations
        </a>
        <div class="header-info">
          <div class="header-icon">
            <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <circle cx="12" cy="12" r="10"></circle>
              <path d="M12 16v-4"></path>
              <path d="M12 8h.01"></path>
            </svg>
          </div>
          <div class="header-text">
            <h1>Galton Board Simulator</h1>
            <p>Interactive demonstration of the binomial distribution and central limit theorem. Watch as random choices at each peg naturally form a bell curve pattern, illustrating fundamental concepts in probability and statistics.</p>
          </div>
          <div class="header-version">
            <span>v1.0.1</span>
            <span class="version-separator">•</span>
            <span>Build 20251202</span>
          </div>
        </div>
      </div>
    </header>

    <!-- Educational Tool Banner -->
    <div class="info-banner">
      <div class="info-icon">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M15 14c.2-1 .7-1.7 1.5-2.5 1-.9 1.5-2.2 1.5-3.5A6 6 0 0 0 6 8c0 1 .2 2.2 1.5 3.5.7.7 1.3 1.5 1.5 2.5"></path>
          <path d="M9 18h6"></path>
          <path d="M10 22h4"></path>
        </svg>
      </div>
      <div class="info-content">
        <strong>Educational Demonstration</strong>
        <p>This simulator helps you understand how the binomial distribution emerges from independent random trials. Each ball makes 50/50 left/right choices at every peg. As more balls drop, the distribution converges to a normal curve, demonstrating the central limit theorem in action.</p>
      </div>
    </div>

        <!-- Content -->
        <div class="tsm-main">
            <div class="tsm-wrap">
      <!-- Left Panel -->
            <div class="left-panel">
                <section class="tsm-card">
          <!-- Simulation Controls -->
          <div style="margin-bottom: 2rem;">
            <h3 style="margin-bottom: 1.25rem;">Simulation Controls</h3>
            
            <div class="form-group">
              <label style="display: flex; align-items: center; gap: 0.25rem; line-height: 1;">
                Drop Mode
                <button class="info-button" data-modal-title="Drop Mode" data-modal-content="Choose between SINGLE DROP (drop one ball at a time) or AUTO DROP (continuously drop balls).&#10;&#10;Use SINGLE DROP for detailed observation of individual ball paths.&#10;&#10;Use AUTO DROP to quickly build up the distribution and see the CENTRAL LIMIT THEOREM in action.">
                  <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-question-mark" aria-hidden="true">
                    <circle cx="12" cy="12" r="10"></circle>
                    <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                    <path d="M12 17h.01"></path>
                  </svg>
                </button>
              </label>
              <div class="segmented" id="dropModeToggle" role="group" aria-label="Drop mode selection">
                <button type="button" class="segment" data-mode="single">Single Drop</button>
                <button type="button" class="segment active" data-mode="auto">Auto Drop</button>
              </div>
            </div>
            
                        <div class="form-group" style="display: flex; gap: 0.5rem; align-items: center;">
                            <button id="startBtn" class="btn-primary-custom" style="flex: 1;">Run</button>
                            <button id="pauseBtn" class="btn-secondary-custom" style="flex: 1;">Pause</button>
                            <button id="reset" class="btn-outline-custom" style="flex: 1;">Reset All</button>
                        </div>
          </div>
          
          <!-- Parameters -->
          <div class="form-group">
            <div class="slider-group">
              <div class="slider-label">
                <label>Number of Rows</label>
                <button class="info-button" data-modal-title="Number of Rows" data-modal-content="Controls the NUMBER OF PEG ROWS in the Galton Board (5-10 rows).&#10;&#10;MORE ROWS create more bins and produce a SMOOTHER, MORE BELL-SHAPED DISTRIBUTION that better demonstrates the CENTRAL LIMIT THEOREM.&#10;&#10;Recommended: Start with 6 rows for balanced visualization.">
                  <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-question-mark" aria-hidden="true">
                    <circle cx="12" cy="12" r="10"></circle>
                    <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                    <path d="M12 17h.01"></path>
                  </svg>
                </button>
              </div>
              <div class="slider-controls">
                <button class="slider-btn" onclick="adjustRows(-1)">−</button>
                <input type="range" id="rowsSlider" min="5" max="10" value="6" step="1">
                <button class="slider-btn" onclick="adjustRows(1)">+</button>
                <span class="slider-value" id="rowsValue">6</span>
              </div>
            </div>
            
                        <div class="slider-group">
                            <div class="slider-label">
                                <label>Number of Balls</label>
                                <button class="info-button" data-modal-title="Number of Balls" data-modal-content="Sets the MAXIMUM NUMBER OF BALLS that can be dropped in each simulation run (1-400 balls).&#10;&#10;Use this to control the SAMPLE SIZE for the histogram and frequency distribution.&#10;&#10;LARGER SAMPLES (200-400) produce more stable distributions that better approximate the theoretical curve.">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-question-mark" aria-hidden="true">
                                        <circle cx="12" cy="12" r="10"></circle>
                                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                                        <path d="M12 17h.01"></path>
                                    </svg>
                                </button>
                            </div>
                            <div class="slider-controls">
                                <button class="slider-btn" onclick="adjustNumBalls(-1)">−</button>
                                <input type="range" id="numBallsSlider" min="1" max="400" step="1" value="200">
                                <button class="slider-btn" onclick="adjustNumBalls(1)">+</button>
                                <span class="slider-value" id="numBallsValue" style="background:#7C3AED;">200</span>
                            </div>
                        </div>

                        <div class="slider-group">
                            <div class="slider-label">
                                <label>Gravity Strength</label>
                                <button class="info-button" data-modal-title="Gravity Strength" data-modal-content="Adjusts the GRAVITATIONAL ACCELERATION affecting ball movement (0.1-0.5).&#10;&#10;HIGHER VALUES (0.4-0.5): Balls fall faster through the pegs - better for quick simulations.&#10;&#10;LOWER VALUES (0.1-0.2): Creates a slower, more observable descent - better for detailed observation.&#10;&#10;Default: 0.30 provides balanced visualization speed.">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-question-mark" aria-hidden="true">
                                        <circle cx="12" cy="12" r="10"></circle>
                                        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                                        <path d="M12 17h.01"></path>
                                    </svg>
                                </button>
                            </div>
                            <div class="slider-controls">
                                <button class="slider-btn" onclick="adjustGravity(-0.01)">−</button>
                                <input type="range" id="gravitySlider" min="0.1" max="0.5" step="0.01" value="0.3">
                                <button class="slider-btn" onclick="adjustGravity(0.01)">+</button>
                                <span class="slider-value orange" id="gravityValue">0.30</span>
                            </div>
                        </div>
          </div>

                    <!-- Visualization Area -->
                    <div style="margin-top: 2rem;">
                        <label style="font-weight: 500; font-size: 0.875rem; color: #0F172A; display: flex; align-items: center; margin-bottom: 0.75rem; gap: 0.25rem; line-height: 1;">
                            Visualization
                            <button class="info-button" data-modal-title="Visualization Toggles" data-modal-content="Control what appears on the histogram:&#10;&#10;• BALL TRAILS: Show the path each ball took through the pegs (useful for understanding randomness)&#10;&#10;• BIN SHADING: Highlights alternating bins for easier counting&#10;&#10;• EMPIRICAL CURVE: Displays a line connecting ACTUAL DATA POINTS (solid purple line)&#10;&#10;• THEORETICAL CURVE: Shows the EXPECTED BINOMIAL DISTRIBUTION (dashed blue line)&#10;&#10;• DESCRIPTIVE MARKERS: Display mean, median, and standard deviation markers">
                              <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-circle-question-mark" aria-hidden="true">
                                <circle cx="12" cy="12" r="10"></circle>
                                <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
                                <path d="M12 17h.01"></path>
                              </svg>
                            </button>
                        </label>
                        <div class="toggle-grid">
                            <!-- Row 1: Ball Trails | Empirical Curve -->
                            <div class="toggle-container">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggleTrails">
                                    <span class="toggle-slider"></span>
                                </label>
                                <label for="toggleTrails" class="toggle-label">Ball Trails</label>
                            </div>
                            <div class="toggle-container">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggleEmpirical">
                                    <span class="toggle-slider"></span>
                                </label>
                                <label for="toggleEmpirical" class="toggle-label">Empirical Curve</label>
                            </div>

                            <!-- Row 2: Bin Shading | Theoretical Curve -->
                            <div class="toggle-container">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggleBinShading">
                                    <span class="toggle-slider"></span>
                                </label>
                                <label for="toggleBinShading" class="toggle-label">Bin Shading</label>
                            </div>
                            <div class="toggle-container">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggleTheoretical">
                                    <span class="toggle-slider"></span>
                                </label>
                                <label for="toggleTheoretical" class="toggle-label">Theoretical Curve</label>
                            </div>

                            <!-- Row 3: Descriptive Markers | (empty) -->
                            <div class="toggle-container">
                                <label class="toggle-switch">
                                    <input type="checkbox" id="toggleDescriptiveMarkers">
                                    <span class="toggle-slider"></span>
                                </label>
                                <label for="toggleDescriptiveMarkers" class="toggle-label">Descriptive Markers</label>
                            </div>
                            <div></div>
                        </div>
                    </div>

          <!-- Statistics -->
          <div style="padding-top: 2rem; border-top: 1px solid var(--border-color);">
            <h3>Statistics</h3>
            
            <div class="stat-row">
              <span class="stat-label">Total Balls Dropped</span>
              <span class="badge" id="totalBalls">0</span>
            </div>
            
            <div class="stat-row">
              <span class="stat-label">Distribution Type</span>
              <span class="badge" id="fitBadge" style="background: #94a3b8;">---</span>
            </div>
            
            <div id="binStats"></div>
            <!-- Simple Frequency Chart -->
            <div id="freqChart" style="margin-top: 0.75rem;">
                <div class="stat-label" style="margin-bottom: 0.5rem; display:flex; align-items:center; justify-content:space-between;">
                    <span>Frequency Chart</span>
                    <div class="dropdown" style="position:relative;">
                        <button id="freqDownloadBtn" class="clear-button" type="button" title="Download" style="padding:4px 6px; display:inline-flex; align-items:center; gap:4px; font-size:0.75rem;">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                                <path d="M12 3v12"></path>
                                <path d="M8 11l4 4 4-4"></path>
                                <path d="M21 21H3"></path>
                            </svg>
                            <svg width="10" height="10" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                                <path d="M6 9l6 6 6-6"></path>
                            </svg>
                        </button>
                        <div id="freqDownloadMenu" class="menu" style="position:absolute; right:0; top:28px; background:#fff; border:1px solid #e2e8f0; border-radius:6px; box-shadow:0 4px 12px rgba(0,0,0,0.08); display:none; min-width:140px; z-index:100;">
                            <button id="freqDownloadPNG" class="menu-item" style="width:100%; text-align:left; padding:8px 10px; background:#fff; border:none; cursor:pointer; font-size:12px; color:#0F172A;">Save as PNG</button>
                            <button id="freqDownloadPDF" class="menu-item" style="width:100%; text-align:left; padding:8px 10px; background:#fff; border:none; cursor:pointer; font-size:12px; color:#0F172A; border-top:1px solid #e2e8f0;">Save as PDF</button>
                        </div>
                    </div>
                </div>
                <table id="freqTable" style="width:95%; margin:0 auto; border-collapse: collapse; font-size: 0.8125rem; border: none !important; padding:0; table-layout: fixed;">
                    <colgroup>
                        <!-- Narrower Bin column -->
                        <col style="width: 12%;">
                        <!-- Evenly spaced remaining columns -->
                        <col style="width: calc((100% - 12%) / 5);">
                        <col style="width: calc((100% - 12%) / 5);">
                        <col style="width: calc((100% - 12%) / 5);">
                        <col style="width: calc((100% - 12%) / 5);">
                        <col style="width: calc((100% - 12%) / 5);">
                    </colgroup>
                    <thead>
                        <tr id="freqHeaderRow" style="border-bottom:1px solid #e2e8f0;">
                            <th style="text-align:left; font-weight:600; color:#0F172A; padding:6px 0;">Bin</th>
                            <th style="text-align:right; font-weight:600; color:#0F172A; padding:6px 0;"><em>f</em></th>
                            <th style="text-align:right; font-weight:600; color:#0F172A; padding:6px 0;"><em>f</em>/n</th>
                            <th style="text-align:right; font-weight:600; color:#0F172A; padding:6px 0;">%<em>f</em></th>
                            <th style="text-align:right; font-weight:600; color:#0F172A; padding:6px 0;">c.%<em>f</em></th>
                            <th style="text-align:right; font-weight:600; color:#0F172A; padding:6px 0;">E[<em>f</em>]</th>
                        </tr>
                    </thead>
                    <tbody id="freqBody"></tbody>
                    <tfoot>
                        <tr id="freqFooterRow" style="border-top:1px solid #e2e8f0;">
                            <td style="padding:6px 0; color:#0F172A; font-weight:600;">Total</td>
                            <td id="freqTotal" style="text-align:right; padding:6px 0; color:#0F172A; font-weight:600;"></td>
                            <td id="relTotal" style="text-align:right; padding:6px 0; color:#475569;"></td>
                            <td id="pctTotal" style="text-align:right; padding:6px 0; color:#475569;"></td>
                            <td id="cumPctTotal" style="text-align:right; padding:6px 0; color:#475569;"></td>
                            <td id="expTotal" style="text-align:right; padding:6px 0; color:#475569;"></td>
                        </tr>
                    </tfoot>
                </table>
                <div style="margin-top:6px; color:#64748b; font-size:0.75rem;">
                    Note: f = frequency; f/n = relative frequency; %f = percent frequency; c.%f = cumulative percent frequency; E[f] = expected count
                </div>
            </div>
          </div>
        </section>
      </div>

      <!-- Right Panel -->
      <div class="right-panel">
        <div class="results-card">
          <div class="results-header-row">
            <h3>Distribution Results</h3>
            <button id="clearAllBtn" class="clear-button" type="button" title="Reset all inputs" style="display: none;">Clear all</button>
          </div>
          <p class="results-subtitle">Based on your simulation parameters</p>
          
          <!-- Value Display Grid -->
          <div class="results-grid">
            <div class="result-item">
              <div class="result-value" id="displayRows">6</div>
              <div class="result-label">Number of Rows</div>
            </div>
            <div class="result-item">
              <div class="result-value purple" id="displayBalls">0</div>
              <div class="result-label">Total Balls</div>
            </div>
            <div class="result-item">
              <div class="result-value effect" id="displayGravity">0.30</div>
              <div class="result-label">Gravity</div>
            </div>
          </div>

                    <!-- Chart Section (Level 1 container) -->
                    <div class="chart-section">
                        <div class="chart-header">
                            <!-- Removed Distribution header and legend items per request -->
                            <div class="curve-style-controls">
                                <span class="curve-control-label">Theme</span>
                                <select id="canvasTheme" class="curve-control-select">
                                    <option value="light" selected>Light</option>
                                    <option value="dark">Dark</option>
                                    <option value="midnight">Midnight</option>
                                    <option value="ocean">Ocean</option>
                                    <option value="forest">Forest</option>
                                    <option value="sunset">Sunset</option>
                                    <option value="lavender">Lavender</option>
                                    <option value="christmas">🎄 Christmas</option>
                                    <option value="halloween">🎃 Halloween</option>
                                    <option value="summer">☀️ Summer</option>
                                </select>
                            </div>
                        </div>
                        <!-- Level 2: unified rectangular inner box with square corners -->
                        <div class="chart-container unified-box">
                            <div class="canvas-toolbar" style="position:absolute; top:8px; right:8px; z-index:10;">
                                <div class="dropdown" style="position:relative;">
                                    <button id="downloadMenuBtn" class="clear-button" type="button" title="Download" style="padding:6px 8px; display:inline-flex; align-items:center; gap:6px;">
                                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
                                            <path d="M12 3v12"></path>
                                            <path d="M8 11l4 4 4-4"></path>
                                            <path d="M21 21H3"></path>
                                        </svg>
                                        <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true" style="margin-left:2px;">
                                            <path d="M6 9l6 6 6-6"></path>
                                        </svg>
                                    </button>
                                    <div id="downloadMenu" class="menu" style="position:absolute; right:0; top:32px; background:#fff; border:1px solid #e2e8f0; border-radius:6px; box-shadow:0 4px 12px rgba(0,0,0,0.08); display:none; min-width:140px;">
                                        <button id="downloadPNG" class="menu-item" style="width:100%; text-align:left; padding:8px 10px; background:#fff; border:none; cursor:pointer; font-size:12px; color:#0F172A;">Save as PNG</button>
                                        <button id="downloadPDF" class="menu-item" style="width:100%; text-align:left; padding:8px 10px; background:#fff; border:none; cursor:pointer; font-size:12px; color:#0F172A; border-top:1px solid #e2e8f0;">Save as PDF</button>
                                    </div>
                                </div>
                            </div>
                            <canvas id="chartCanvas" width="800" height="800"></canvas>
                        </div>
                    </div>
        </div>
      </div>
      </div>
    </div>
  </div>
  
  <!-- Footer -->
  <footer class="app-footer">
    <div class="footer-content">
      <div class="footer-left">
        <span class="footer-brand">TSM Galton Board Simulator</span>
        <span class="footer-separator">•</span>
        <span class="footer-version">v1.0.2</span>
        <span class="footer-separator">•</span>
        <span class="footer-build">Build 20251202-2</span>
      </div>
      <div class="footer-right">
        <a href="index.html" class="footer-link">Back to Demonstrations</a>
      </div>
    </div>
  </footer>

  <!-- Info Modal -->
  <div id="infoModal" class="modal" aria-hidden="true">
    <div class="modal-overlay"></div>
    <div class="modal-container">
      <div class="modal-header">
        <h2 id="modalTitle" class="modal-title">Information</h2>
        <button class="modal-close" aria-label="Close modal">
          <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      </div>
      <div class="modal-body">
        <p id="modalContent"></p>
      </div>
    </div>
  </div>

    <script>
        // Firebase Configuration
        let db = null;
        let unsubscribe = null;
        
        // Initialize Firebase
        async function initFirebase() {
            if (typeof __firebase_config === 'undefined' || typeof __app_id === 'undefined') {
                console.log('Running in local mode - stats will not persist');
                return false;
            }
            
            try {
                firebase.initializeApp(__firebase_config);
                
                // Auth
                if (typeof __initial_auth_token !== 'undefined') {
                    await firebase.auth().signInWithCustomToken(__initial_auth_token);
                } else {
                    await firebase.auth().signInAnonymously();
                }
                
                db = firebase.firestore();
                setupRealtimeSync();
                return true;
            } catch (error) {
                console.error('Firebase init failed:', error);
                return false;
            }
        }

        // Visualization defaults
        const TOGGLES = { 
            showBars: true, 
            unifiedColor: true, 
            showBinLabels: true,
            showTrails: false,
            showBinShading: false,
            showTheoretical: false,
            showEmpirical: false,
            showDescriptiveMarkers: false
        };
        const unifiedColor = '#7C3AED';

        // Theme Configuration
        const THEMES = {
            light: {
                background: '#f8fafc',
                pegHead: '#ef4444',
                pegShine: '#fca5a5',
                pegShaft: '#94a3b8',
                pegPoint: '#64748b',
                pegType: 'pin'
            },
            dark: {
                background: '#1e293b',
                pegHead: '#dc2626',
                pegShine: '#f87171',
                pegShaft: '#64748b',
                pegPoint: '#475569',
                pegType: 'pin'
            },
            midnight: {
                background: '#0f172a',
                pegHead: '#8b5cf6',
                pegShine: '#c4b5fd',
                pegShaft: '#475569',
                pegPoint: '#334155',
                pegType: 'pin'
            },
            ocean: {
                background: '#ecfeff',
                pegHead: '#06b6d4',
                pegShine: '#67e8f9',
                pegShaft: '#0e7490',
                pegPoint: '#155e75',
                pegType: 'pin'
            },
            forest: {
                background: '#f0fdf4',
                pegHead: '#10b981',
                pegShine: '#6ee7b7',
                pegShaft: '#059669',
                pegPoint: '#047857',
                pegType: 'pin'
            },
            sunset: {
                background: '#fff7ed',
                pegHead: '#f97316',
                pegShine: '#fdba74',
                pegShaft: '#ea580c',
                pegPoint: '#c2410c',
                pegType: 'pin'
            },
            lavender: {
                background: '#faf5ff',
                pegHead: '#a855f7',
                pegShine: '#d8b4fe',
                pegShaft: '#9333ea',
                pegPoint: '#7e22ce',
                pegType: 'pin'
            },
            christmas: {
                background: '#fee',
                pegHead: '#dc2626',
                pegShine: '#fef08a',
                pegShaft: '#16a34a',
                pegPoint: '#166534',
                pegType: 'ornament',
                pegAccent: '#fbbf24'
            },
            halloween: {
                background: '#1a0b2e',
                pegHead: '#f97316',
                pegShine: '#fbbf24',
                pegShaft: '#6b21a8',
                pegPoint: '#4c1d95',
                pegType: 'pumpkin',
                pegAccent: '#059669'
            },
            summer: {
                background: '#e0f2fe',
                pegHead: '#fbbf24',
                pegShine: '#fef3c7',
                pegShaft: '#0ea5e9',
                pegPoint: '#0284c7',
                pegType: 'sun',
                pegAccent: '#fb923c'
            }
        };
        
        let currentTheme = THEMES.light;
        
        // Configuration
        const CONFIG = {
            width: 800,
            height: 800,
            pegRadius: 5,
            ballRadius: 6,
            gravity: 0.3,
            drag: 0.96,
            rows: 6,
            maxBalls: 200,
            pegSpacingX: 60,
            pegSpacingY: 50,
            startX: 400,
            startY: 50
        };

        // State
        let bins = Array(CONFIG.rows + 1).fill(0);
        let totalBalls = 0;
        let isAutoDropping = false;
        let autoInterval = null;
        let balls = [];
        let allTrails = [];
        let settledBalls = [];
        let pegs = [];
        let animationId = null;
        let useFirebase = false;

        // Canvas setup (single unified canvas)
        const canvas = document.getElementById('chartCanvas');
        const ctx = canvas.getContext('2d');

        // Initialize pegs
        function initPegs() {
            pegs = [];
            const rows = CONFIG.rows;
            // Start first peg row well below funnel exit (funnel ends at y=70)
            const firstPegY = 110;
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col <= row; col++) {
                    const xOffset = (col - row / 2) * CONFIG.pegSpacingX;
                    const x = CONFIG.startX + xOffset;
                    const y = firstPegY + row * CONFIG.pegSpacingY;
                    pegs.push({ x, y });
                }
            }
        }

        // Ball class
        class Ball {
            constructor() {
                // Start ball inside funnel at random position in top opening
                this.x = CONFIG.startX + (Math.random() - 0.5) * 50; // Random position across funnel opening
                this.y = 35; // Start near top of funnel
                this.vx = 0;
                this.vy = 0.5; // Small initial downward velocity
                this.radius = Math.max(CONFIG.ballRadius, CONFIG.pegRadius * 1.5); // Increase ball size for reliable peg contact
                // Use TSM purple
                this.color = '#7C3AED';
                this.active = true;
                this.inFunnel = true;
                this.currentRow = -1; // Track which peg row we've processed
                this.trail = [{x: this.x, y: this.y}]; // Store previous positions for trail
            }

            update() {
                // Funnel collision detection
                if (this.inFunnel && this.y < 75) {
                    const funnelTopY = 30;
                    const funnelBottomY = 70;
                    const funnelTopWidth = 60;
                    const funnelBottomWidth = 8;
                    
                    // Calculate funnel width at current Y position
                    const funnelProgress = (this.y - funnelTopY) / (funnelBottomY - funnelTopY);
                    const currentWidth = funnelTopWidth - (funnelTopWidth - funnelBottomWidth) * funnelProgress;
                    const leftBound = CONFIG.startX - currentWidth / 2;
                    const rightBound = CONFIG.startX + currentWidth / 2;
                    
                    // Constrain ball to funnel walls
                    if (this.x - this.radius < leftBound) {
                        this.x = leftBound + this.radius;
                        this.vx = Math.abs(this.vx) * 0.3; // Bounce off left wall gently
                    }
                    if (this.x + this.radius > rightBound) {
                        this.x = rightBound - this.radius;
                        this.vx = -Math.abs(this.vx) * 0.3; // Bounce off right wall gently
                    }
                    
                    // Add slight funnel friction
                    this.vx *= 0.95;
                } else {
                    this.inFunnel = false;
                }
                
                // Apply physics
                this.vx *= CONFIG.drag;
                this.vy += CONFIG.gravity;
                this.x += this.vx;
                this.y += this.vy;
                // Store position for trail (limit to last 100 points)
                if (!this.trail) this.trail = [];
                this.trail.push({x: this.x, y: this.y});
                if (this.trail.length > 100) this.trail.shift();

                // Peg collisions - ensure we hit exactly one peg per row
                const firstPegY = 110;
                const currentRowIndex = Math.floor((this.y - firstPegY) / CONFIG.pegSpacingY);

                // Process ALL rows we've entered since last update (in case ball skips rows)
                if (currentRowIndex >= 0 && currentRowIndex < CONFIG.rows && currentRowIndex > this.currentRow) {
                    for (let rowToProcess = this.currentRow + 1; rowToProcess <= currentRowIndex && rowToProcess < CONFIG.rows; rowToProcess++) {
                        // Find the peg for this row (pegs are spaced horizontally)
                        const pegRowY = firstPegY + rowToProcess * CONFIG.pegSpacingY;
                        // Pegs in this row: index from 0 to rowToProcess
                        const pegCols = rowToProcess + 1;
                        // Find which peg the ball should hit based on its x position
                        let closestPeg = null;
                        let minDist = Infinity;
                        for (let peg of pegs) {
                            if (Math.abs(peg.y - pegRowY) < 1) {
                                const dist = Math.abs(this.x - peg.x);
                                if (dist < minDist) {
                                    minDist = dist;
                                    closestPeg = peg;
                                }
                            }
                        }
                        // Force the ball to interact with the top of the peg
                        if (closestPeg) {
                            // Force ball to hit the peg: align x to peg center before deflection
                            this.x = closestPeg.x;
                            this.y = closestPeg.y - this.radius - CONFIG.pegRadius;
                            // Determine L/R by which side of peg center the ball is (randomize for visual variety)
                            let goLeft = Math.random() < 0.5;
                            if (!this.path) this.path = '';
                            this.path += goLeft ? 'L' : 'R';
                            // Deflect ball
                            if (rowToProcess === currentRowIndex) {
                                this.vx = goLeft ? -2.5 : 2.5;
                                this.vy = 1.5;
                            }
                        } else {
                            // Fallback to random if no peg found
                            let goLeft = Math.random() < 0.5;
                            if (!this.path) this.path = '';
                            this.path += goLeft ? 'L' : 'R';
                            if (rowToProcess === currentRowIndex) {
                                this.vx = goLeft ? -2.5 : 2.5;
                                this.vy = 1.5;
                            }
                        }
                    }
                    this.currentRow = currentRowIndex;
                }
                
                // Still handle physical peg collisions for realistic bouncing off TOP
                for (let i = 0; i < pegs.length; i++) {
                    const peg = pegs[i];
                    const dx = this.x - peg.x;
                    const dy = this.y - peg.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const minDistance = this.radius + CONFIG.pegRadius;

                    if (distance < minDistance && dy > 0) {
                        // Only bounce if hitting from above (dy > 0)
                        const angle = Math.atan2(dy, dx);
                        const pushDistance = minDistance - distance + 1;
                        this.x += Math.cos(angle) * pushDistance;
                        this.y += Math.sin(angle) * pushDistance;
                        break;
                    }
                }

                // Bin detection - trigger shortly after passing last peg row
                const lastPegRow = CONFIG.rows - 1;
                const lastPegY = firstPegY + lastPegRow * CONFIG.pegSpacingY;
                const binDetectionY = lastPegY + CONFIG.pegSpacingY * 0.5; // Half a row below last peg
                
                if (this.y > binDetectionY) {
                    // CRITICAL: Ensure we've processed all rows before determining bin
                    // Force processing of any remaining rows
                    if (this.y > lastPegY && this.currentRow < lastPegRow) {
                        // We passed the last peg row but didn't process it
                        for (let rowToProcess = this.currentRow + 1; rowToProcess < CONFIG.rows; rowToProcess++) {
                            const goLeft = Math.random() < 0.5;
                            if (!this.path) this.path = '';
                            this.path += goLeft ? 'L' : 'R';
                        }
                        this.currentRow = lastPegRow;
                    }
                    
                    // Bin is determined by the path, not final position
                    // Track position: start at 0, L means -1, R means +1
                    let binIndex;
                    if (this.path && this.path.length === CONFIG.rows) {
                        // Calculate position by walking through path
                        let position = 0;
                        for (let i = 0; i < this.path.length; i++) {
                            position += this.path[i] === 'R' ? 1 : -1;
                        }
                        // Position ranges from -CONFIG.rows to +CONFIG.rows
                        // LLLLLL: pos=-6, bin=0; RRRRRR: pos=+6, bin=6
                        // Formula: binIndex = (position + CONFIG.rows) / 2
                        binIndex = Math.floor((position + CONFIG.rows) / 2);
                    } else {
                        // Fallback to position-based if path is incomplete
                        const binCount = CONFIG.rows + 1;
                        const binWidth = CONFIG.pegSpacingX;
                        const centers = [];
                        for (let i = 0; i < binCount; i++) {
                            centers.push(CONFIG.startX + (i - CONFIG.rows / 2) * binWidth);
                        }
                        binIndex = 0;
                        let bestDist = Infinity;
                        for (let i = 0; i < binCount; i++) {
                            const d = Math.abs(this.x - centers[i]);
                            if (d < bestDist) { bestDist = d; binIndex = i; }
                        }
                    }
                    
                    // Freeze the ball immediately to prevent drift
                    this.vx = 0;
                    this.vy = 0;
                    
                    // Update counts
                    if (useFirebase && db) {
                        incrementBinFirebase(binIndex);
                    } else {
                        bins[binIndex]++;
                        totalBalls++;
                        updateStats();
                    }

                    // Ball disappears - just mark as inactive, don't add to settledBalls
                    // Save trail for permanent display
                    if (this.trail && this.trail.length > 1) {
                        allTrails.push([...this.trail]);
                    }
                    this.active = false;
                    return;
                }

                // Wall collisions
                if (this.x < this.radius) {
                    this.x = this.radius;
                    this.vx *= -1;
                } else if (this.x > CONFIG.width - this.radius) {
                    this.x = CONFIG.width - this.radius;
                    this.vx *= -1;
                }
            }

            draw() {
                // Draw trail (faint line) - only if toggle is on
                if (TOGGLES.showTrails && this.trail && this.trail.length > 1) {
                    ctx.save();
                    ctx.strokeStyle = 'rgba(124,58,237,0.3)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(this.trail[0].x, this.trail[0].y);
                    for (let i = 1; i < this.trail.length; i++) {
                        ctx.lineTo(this.trail[i].x, this.trail[i].y);
                    }
                    ctx.stroke();
                    ctx.restore();
                }
                ctx.fillStyle = TOGGLES.unifiedColor ? unifiedColor : this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Shine
                ctx.fillStyle = 'rgba(255,255,255,0.4)';
                ctx.beginPath();
                ctx.arc(this.x - 2, this.y - 2, 2, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Animation loop
        function animate() {
            // Slow motion mode - skip frames to slow down
            if (slowMotion) {
                frameSkip++;
                if (frameSkip < 5) {
                    animationId = requestAnimationFrame(animate);
                    return;
                }
                frameSkip = 0;
            }
            
            ctx.clearRect(0, 0, CONFIG.width, CONFIG.height);

            // Draw funnel
            const funnelX = CONFIG.startX;
            const funnelTopY = 30;
            const funnelBottomY = 70;
            const funnelTopWidth = 60;
            const funnelBottomWidth = 8;
            
            // Funnel gradient
            const gradient = ctx.createLinearGradient(funnelX, funnelTopY, funnelX, funnelBottomY);
            gradient.addColorStop(0, '#cbd5e1');
            gradient.addColorStop(1, '#94a3b8');
            
            // Draw funnel shape
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(funnelX - funnelTopWidth / 2, funnelTopY);
            ctx.lineTo(funnelX + funnelTopWidth / 2, funnelTopY);
            ctx.lineTo(funnelX + funnelBottomWidth / 2, funnelBottomY);
            ctx.lineTo(funnelX - funnelBottomWidth / 2, funnelBottomY);
            ctx.closePath();
            ctx.fill();
            
            // Funnel outline
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Funnel opening (bottom tube)
            ctx.fillStyle = '#94a3b8';
            ctx.fillRect(funnelX - funnelBottomWidth / 2, funnelBottomY, funnelBottomWidth, 5);
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(funnelX - funnelBottomWidth / 2, funnelBottomY, funnelBottomWidth, 5);
            
            // Funnel highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.moveTo(funnelX - funnelTopWidth / 2 + 5, funnelTopY + 2);
            ctx.lineTo(funnelX - funnelTopWidth / 2 + 15, funnelTopY + 2);
            ctx.lineTo(funnelX - funnelBottomWidth / 2 + 3, funnelBottomY - 2);
            ctx.lineTo(funnelX - funnelBottomWidth / 2 + 1, funnelBottomY - 2);
            ctx.closePath();
            ctx.fill();

            // Draw pegs (themed)
            pegs.forEach(peg => {
                if (currentTheme.pegType === 'ornament') {
                    // Christmas ornament
                    // Ornament ball
                    ctx.fillStyle = currentTheme.pegHead;
                    ctx.beginPath();
                    ctx.arc(peg.x, peg.y, CONFIG.pegRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Gold cap on top
                    ctx.fillStyle = currentTheme.pegAccent;
                    ctx.fillRect(peg.x - 2, peg.y - CONFIG.pegRadius - 2, 4, 2);
                    
                    // Hanger
                    ctx.strokeStyle = currentTheme.pegAccent;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(peg.x, peg.y - CONFIG.pegRadius - 2);
                    ctx.lineTo(peg.x, peg.y - CONFIG.pegRadius - 5);
                    ctx.stroke();
                    
                    // Shine
                    ctx.fillStyle = currentTheme.pegShine;
                    ctx.beginPath();
                    ctx.arc(peg.x - 1.5, peg.y - 1, 2, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else if (currentTheme.pegType === 'pumpkin') {
                    // Halloween pumpkin
                    // Pumpkin body
                    ctx.fillStyle = currentTheme.pegHead;
                    ctx.beginPath();
                    ctx.arc(peg.x, peg.y, CONFIG.pegRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Stem
                    ctx.fillStyle = currentTheme.pegAccent;
                    ctx.fillRect(peg.x - 1, peg.y - CONFIG.pegRadius - 3, 2, 3);
                    
                    // Ridges
                    ctx.strokeStyle = '#c2410c';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(peg.x - 2, peg.y - CONFIG.pegRadius);
                    ctx.lineTo(peg.x - 2, peg.y + CONFIG.pegRadius);
                    ctx.moveTo(peg.x + 2, peg.y - CONFIG.pegRadius);
                    ctx.lineTo(peg.x + 2, peg.y + CONFIG.pegRadius);
                    ctx.stroke();
                    
                    // Face (eyes and mouth)
                    ctx.fillStyle = '#000';
                    ctx.fillRect(peg.x - 2, peg.y - 1, 1, 1);
                    ctx.fillRect(peg.x + 1, peg.y - 1, 1, 1);
                    ctx.fillRect(peg.x - 1, peg.y + 1, 2, 1);
                    
                } else if (currentTheme.pegType === 'sun') {
                    // Summer sun
                    // Sun center
                    ctx.fillStyle = currentTheme.pegHead;
                    ctx.beginPath();
                    ctx.arc(peg.x, peg.y, CONFIG.pegRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Sun rays
                    ctx.strokeStyle = currentTheme.pegAccent;
                    ctx.lineWidth = 2;
                    for (let i = 0; i < 8; i++) {
                        const angle = (Math.PI * 2 * i) / 8;
                        const x1 = peg.x + Math.cos(angle) * (CONFIG.pegRadius + 1);
                        const y1 = peg.y + Math.sin(angle) * (CONFIG.pegRadius + 1);
                        const x2 = peg.x + Math.cos(angle) * (CONFIG.pegRadius + 4);
                        const y2 = peg.y + Math.sin(angle) * (CONFIG.pegRadius + 4);
                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                    
                    // Shine
                    ctx.fillStyle = currentTheme.pegShine;
                    ctx.beginPath();
                    ctx.arc(peg.x - 1, peg.y - 1, 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    
                } else {
                    // Default pin
                    // Pin shaft below
                    ctx.strokeStyle = currentTheme.pegShaft;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(peg.x, peg.y + CONFIG.pegRadius);
                    ctx.lineTo(peg.x, peg.y + CONFIG.pegRadius + 5);
                    ctx.stroke();
                    
                    // Pin point
                    ctx.fillStyle = currentTheme.pegPoint;
                    ctx.beginPath();
                    ctx.moveTo(peg.x - 1, peg.y + CONFIG.pegRadius + 5);
                    ctx.lineTo(peg.x + 1, peg.y + CONFIG.pegRadius + 5);
                    ctx.lineTo(peg.x, peg.y + CONFIG.pegRadius + 7);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Pin head
                    ctx.fillStyle = currentTheme.pegHead;
                    ctx.beginPath();
                    ctx.arc(peg.x, peg.y, CONFIG.pegRadius, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Shine on pin head
                    ctx.fillStyle = currentTheme.pegShine;
                    ctx.beginPath();
                    ctx.arc(peg.x - 1.5, peg.y - 1, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

            // Update and draw balls
            balls = balls.filter(ball => {
                if (ball.active) {
                    ball.update();
                    ball.draw();
                    return true;
                }
                return false;
            });

            // Draw all persistent trails - only if toggle is on
            if (TOGGLES.showTrails && allTrails.length) {
                ctx.save();
                ctx.strokeStyle = 'rgba(124,58,237,0.2)';
                ctx.lineWidth = 2;
                for (const trail of allTrails) {
                    if (trail.length > 1) {
                        ctx.beginPath();
                        ctx.moveTo(trail[0].x, trail[0].y);
                        for (let i = 1; i < trail.length; i++) {
                            ctx.lineTo(trail[i].x, trail[i].y);
                        }
                        ctx.stroke();
                    }
                }
                ctx.restore();
            }

            // Draw bin lines and labels
            const binCount = CONFIG.rows + 1;
            const binWidth = CONFIG.pegSpacingX;
            const BALL_D = CONFIG.ballRadius * 2;
            const maxCount = Math.max(...bins, 1);
            // Fixed baseline at bottom of canvas - moved up to make room for markers
            const binLineY = CONFIG.height - 180;
            const binLabelY = Math.min(CONFIG.height - 100, binLineY + 20);
            // Bins should align with spaces between bottom row pegs
            // Bottom row has CONFIG.rows pegs positioned at (col - (CONFIG.rows-1)/2)
            const bottomRowPegCount = CONFIG.rows;
            const leftEdge = CONFIG.startX - (bottomRowPegCount / 2) * binWidth;
            const rightEdge = CONFIG.startX + (bottomRowPegCount / 2) * binWidth;
            
            // Calculate available space and scaling
            const bottomPegY = pegs.length ? Math.max(...pegs.map(p => p.y)) : 340;
            const availableHeight = binLineY - bottomPegY - 40; // 40pt safety margin
            const maxBarHeight = maxCount * BALL_D;
            const scale = maxBarHeight > availableHeight ? availableHeight / maxBarHeight : 1;
            
            ctx.strokeStyle = '#005EE9'; // Primary blue for lines
            ctx.lineWidth = 2;
            ctx.font = '14px Inter';
            ctx.textAlign = 'center';
            
            // Draw only horizontal bin lines and labels (no vertical lines)
            for (let i = 0; i < binCount; i++) {
                const binX = CONFIG.startX + (i - CONFIG.rows / 2) * binWidth;
                const gap = 1.5;
                ctx.beginPath();
                ctx.moveTo(binX - binWidth / 2 + gap, binLineY);
                ctx.lineTo(binX + binWidth / 2 - gap, binLineY);
                ctx.stroke();
                if (TOGGLES.showBinLabels) {
                    ctx.fillStyle = '#64748b';
                    ctx.fillText((i + 1).toString(), binX, binLabelY);
                }
            }

            // Calculate correct bin boundaries for bars
            const barBinEdges = [];
            for (let i = 0; i <= binCount; i++) {
                const edgeX = CONFIG.startX + (i - 0.5 - CONFIG.rows / 2) * binWidth;
                barBinEdges.push(edgeX);
            }
            
            // Draw bars (always visible now)
            for (let i = 0; i < binCount; i++) {
                const count = bins[i];
                if (!count) continue;
                const leftEdge = barBinEdges[i];
                const rightEdge = barBinEdges[i + 1];
                const barWidth = rightEdge - leftEdge;
                const barHeight = count * BALL_D * scale;
                const topY = binLineY - barHeight;
                const gap = 6;
                ctx.fillStyle = 'rgba(124,58,237,0.4)';
                ctx.beginPath();
                ctx.rect(leftEdge + gap, topY, barWidth - gap * 2, barHeight);
                ctx.fill();
                ctx.strokeStyle = 'rgba(124,58,237,0.8)';
                ctx.lineWidth = 2;
                ctx.strokeRect(leftEdge + gap, topY, barWidth - gap * 2, barHeight);
            }
            
            // TROUBLESHOOTING: Draw lines from each bin to corresponding bottom peg
            const troubleshootBinCount = CONFIG.rows + 1;
            const troubleshootBinWidth = CONFIG.pegSpacingX;
            const troubleshootBinLineY = CONFIG.height - 100;
            const bottomPegRow = CONFIG.rows - 1; // Last row of pegs (row 5 for 6 rows)
            const troubleshootFirstPegY = 110;
            const troubleshootBottomPegY = troubleshootFirstPegY + bottomPegRow * CONFIG.pegSpacingY;
            
            // Store left and right edges of each bin area
            // Bins are centered at regular intervals, edges are halfway between centers
            const binEdges = [];
            
            for (let i = 0; i <= troubleshootBinCount; i++) {
                // Edge i is halfway between bin i-1 and bin i
                // Bin centers are at: CONFIG.startX + (binIndex - CONFIG.rows/2) * binWidth
                // Edge is at: CONFIG.startX + (i - 0.5 - CONFIG.rows/2) * binWidth
                const edgeX = CONFIG.startX + (i - 0.5 - CONFIG.rows / 2) * troubleshootBinWidth;
                binEdges.push(edgeX);
            }
            
            // Shade each bin area between the edges (only if toggle is on)
            if (TOGGLES.showBinShading) {
                for (let i = 0; i < troubleshootBinCount; i++) {
                    const leftEdge = binEdges[i];
                    const rightEdge = binEdges[i + 1];
                    
                    // Shade the bin area with alternating subtle colors
                    ctx.fillStyle = i % 2 === 0 ? 'rgba(124, 58, 237, 0.08)' : 'rgba(59, 130, 246, 0.08)';
                    ctx.fillRect(leftEdge, troubleshootBottomPegY, rightEdge - leftEdge, troubleshootBinLineY - troubleshootBottomPegY);
                    
                    // Add subtle borders on left and right edges
                    ctx.strokeStyle = 'rgba(100, 116, 139, 0.15)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    // Left border
                    ctx.moveTo(leftEdge, troubleshootBottomPegY);
                    ctx.lineTo(leftEdge, troubleshootBinLineY);
                    // Right border
                    ctx.moveTo(rightEdge, troubleshootBottomPegY);
                    ctx.lineTo(rightEdge, troubleshootBinLineY);
                    ctx.stroke();
                }
            }
            
            // Empirical curve overlay (actual data) - only if toggle is on
            if (TOGGLES.showEmpirical && totalBalls > 0) {
                ctx.strokeStyle = '#7C3AED'; // Primary purple
                ctx.lineWidth = 3;
                ctx.beginPath();
                let firstPoint = true;
                for (let i = 0; i < binCount; i++) {
                    const count = bins[i];
                    const actualHeight = count * BALL_D * scale;
                    const centerX = CONFIG.startX + (i - CONFIG.rows / 2) * binWidth;
                    const y = binLineY - actualHeight;
                    if (firstPoint) {
                        ctx.moveTo(centerX, y);
                        firstPoint = false;
                    } else {
                        ctx.lineTo(centerX, y);
                    }
                }
                ctx.stroke();
                
                // Draw dots at each data point
                for (let i = 0; i < binCount; i++) {
                    const count = bins[i];
                    const actualHeight = count * BALL_D * scale;
                    const centerX = CONFIG.startX + (i - CONFIG.rows / 2) * binWidth;
                    const y = binLineY - actualHeight;
                    ctx.fillStyle = '#7C3AED';
                    ctx.beginPath();
                    ctx.arc(centerX, y, 5, 0, Math.PI * 2);
                    ctx.fill();
                    // White center for contrast
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(centerX, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Theoretical curve overlay (binomial distribution) - only if toggle is on
            if (TOGGLES.showTheoretical) {
                // Use a fixed reference sample size for consistent display
                const referenceBalls = 100;
                
                // Calculate theoretical curve with smooth interpolation
                ctx.strokeStyle = '#005EE9'; // Primary blue
                ctx.lineWidth = 3;
                ctx.setLineDash([6, 4]); // Dashed line to distinguish from empirical
                
                // Generate smooth curve using more points
                const smoothPoints = [];
                for (let i = 0; i < binCount; i++) {
                    const p = binomialProbability(CONFIG.rows, i, 0.5);
                    const expected = p * referenceBalls;
                    // Use 95% of available height to accommodate taller bars
                    const maxTheoreticalHeight = availableHeight * 0.95;
                    // Find max theoretical probability to scale properly
                    let maxP = 0;
                    for (let j = 0; j < binCount; j++) {
                        const prob = binomialProbability(CONFIG.rows, j, 0.5);
                        if (prob > maxP) maxP = prob;
                    }
                    const heightScale = maxTheoreticalHeight / (maxP * referenceBalls * BALL_D);
                    const expectedHeight = expected * BALL_D * heightScale;
                    const centerX = CONFIG.startX + (i - CONFIG.rows / 2) * binWidth;
                    const y = binLineY - expectedHeight;
                    smoothPoints.push({ x: centerX, y: y });
                }
                
                // Draw smooth curve
                ctx.beginPath();
                if (smoothPoints.length > 0) {
                    ctx.moveTo(smoothPoints[0].x, smoothPoints[0].y);
                    
                    // Use quadratic curves for smoothness
                    for (let i = 0; i < smoothPoints.length - 1; i++) {
                        const xc = (smoothPoints[i].x + smoothPoints[i + 1].x) / 2;
                        const yc = (smoothPoints[i].y + smoothPoints[i + 1].y) / 2;
                        ctx.quadraticCurveTo(smoothPoints[i].x, smoothPoints[i].y, xc, yc);
                    }
                    // Last point
                    const last = smoothPoints[smoothPoints.length - 1];
                    ctx.lineTo(last.x, last.y);
                }
                ctx.stroke();
                ctx.setLineDash([]); // Reset dash
            }
            
            // Statistical markers (mean, median, mode) below bins
            if (TOGGLES.showDescriptiveMarkers) {
                const markerStartY = binLabelY + 30; // Start below bin labels
                const lineHeight = 25; // Space between each marker line
                
                let meanX, medianX, modeXPositions, modeBins;
                
                if (totalBalls > 0) {
                    // Calculate mean
                    let weightedSum = 0;
                    for (let i = 0; i < bins.length; i++) {
                        weightedSum += i * bins[i];
                    }
                    const meanBin = weightedSum / totalBalls;
                    meanX = CONFIG.startX + (meanBin - CONFIG.rows / 2) * binWidth;
                    
                    // Calculate median
                    const halfBalls = totalBalls / 2;
                    let cumulative = 0;
                    let medianBin = 0;
                    for (let i = 0; i < bins.length; i++) {
                        cumulative += bins[i];
                        if (cumulative >= halfBalls) {
                            medianBin = i;
                            break;
                        }
                    }
                    medianX = CONFIG.startX + (medianBin - CONFIG.rows / 2) * binWidth;
                    
                    // Calculate mode (bin with most balls) - support multimodal distributions
                    let maxCount = 0;
                    modeBins = [];
                    
                    // Find the maximum count
                    for (let i = 0; i < bins.length; i++) {
                        if (bins[i] > maxCount) {
                            maxCount = bins[i];
                        }
                    }
                    
                    // Find all bins with the maximum count (multimodal)
                    for (let i = 0; i < bins.length; i++) {
                        if (bins[i] === maxCount && maxCount > 0) {
                            modeBins.push(i);
                        }
                    }
                    
                    // Calculate x positions for all modes
                    modeXPositions = modeBins.map(bin => 
                        CONFIG.startX + (bin - CONFIG.rows / 2) * binWidth
                    );
                } else {
                    // Default to middle position when no balls have been dropped
                    const middleBin = CONFIG.rows / 2;
                    meanX = CONFIG.startX;
                    medianX = CONFIG.startX;
                    modeXPositions = [CONFIG.startX];
                    modeBins = [Math.floor(middleBin)];
                }
                
                // Helper function to draw marker line
                function drawMarkerLine(y, markerX, label, color) {
                    // Lines span from left edge of bin 0 to right edge of last bin
                    const lineStartX = barBinEdges[0];
                    const lineEndX = barBinEdges[barBinEdges.length - 1];
                    
                    // Draw horizontal line
                    ctx.strokeStyle = color;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(lineStartX, y);
                    ctx.lineTo(lineEndX, y);
                    ctx.stroke();
                    
                    // Draw pointer (triangle pointing up)
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.moveTo(markerX, y - 8);
                    ctx.lineTo(markerX - 5, y - 1);
                    ctx.lineTo(markerX + 5, y - 1);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Draw label
                    ctx.fillStyle = '#0F172A';
                    ctx.font = '12px Inter';
                    ctx.textAlign = 'left';
                    ctx.fillText(label, lineEndX + 10, y + 4);
                }
                
                // Draw all three markers
                drawMarkerLine(markerStartY, meanX, 'Mean', '#10b981'); // Green
                drawMarkerLine(markerStartY + lineHeight, medianX, 'Median', '#f59e0b'); // Orange
                
                // Draw mode line with multiple pointers if multimodal
                const modeY = markerStartY + lineHeight * 2;
                const lineStartX = barBinEdges[0];
                const lineEndX = barBinEdges[barBinEdges.length - 1];
                
                // Draw horizontal line for mode
                ctx.strokeStyle = '#6366f1'; // Indigo
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(lineStartX, modeY);
                ctx.lineTo(lineEndX, modeY);
                ctx.stroke();
                
                // Draw pointer(s) for mode - one for each mode in multimodal distributions
                ctx.fillStyle = '#6366f1';
                for (const modeX of modeXPositions) {
                    ctx.beginPath();
                    ctx.moveTo(modeX, modeY - 8);
                    ctx.lineTo(modeX - 5, modeY - 1);
                    ctx.lineTo(modeX + 5, modeY - 1);
                    ctx.closePath();
                    ctx.fill();
                }
                
                // Draw label with indication of multimodal if applicable
                ctx.fillStyle = '#0F172A';
                ctx.font = '12px Inter';
                ctx.textAlign = 'left';
                const modeLabel = modeBins.length > 1 ? `Mode (${modeBins.length})` : 'Mode';
                ctx.fillText(modeLabel, lineEndX + 10, modeY + 4);
            }

            animationId = requestAnimationFrame(animate);
        }

        // Firebase Functions
        function setupRealtimeSync() {
            if (!db || typeof __app_id === 'undefined') return;
            
            const docRef = db.collection('artifacts').doc(__app_id)
                .collection('public').doc('data')
                .collection('plinko_stats').doc('global_tally');
            
            unsubscribe = docRef.onSnapshot((doc) => {
                if (doc.exists) {
                    const data = doc.data();
                    const newBins = [];
                    for (let i = 0; i <= CONFIG.rows; i++) {
                        newBins.push(data[`bin${i}`] || 0);
                    }
                    bins = newBins;
                    totalBalls = bins.reduce((a, b) => a + b, 0);
                    updateStats();
                }
            }, (error) => {
                console.error('Firestore sync error:', error);
            });
        }

        async function incrementBinFirebase(binIndex) {
            if (!db || typeof __app_id === 'undefined') return;
            
            const docRef = db.collection('artifacts').doc(__app_id)
                .collection('public').doc('data')
                .collection('plinko_stats').doc('global_tally');
            
            try {
                await db.runTransaction(async (transaction) => {
                    const doc = await transaction.get(docRef);
                    const binField = `bin${binIndex}`;
                    const currentValue = doc.exists ? (doc.data()[binField] || 0) : 0;
                    transaction.set(docRef, {
                        [binField]: currentValue + 1
                    }, { merge: true });
                });
            } catch (error) {
                console.error('Firebase increment error:', error);
                // Fallback to local
                bins[binIndex]++;
                totalBalls++;
                updateStats();
            }
        }

        // Add ball
        function addBall() {
            const activeCount = totalBalls + balls.length;
            if (activeCount >= CONFIG.maxBalls) return;
            balls.push(new Ball());
        }

        // Binomial probability function
        function binomialProbability(n, k, p) {
            function factorial(num) {
                if (num <= 1) return 1;
                let result = 1;
                for (let i = 2; i <= num; i++) result *= i;
                return result;
            }
            
            function combinations(n, k) {
                if (k > n) return 0;
                if (k === 0 || k === n) return 1;
                return factorial(n) / (factorial(k) * factorial(n - k));
            }
            
            return combinations(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
        }
        
        // No separate histogram chart - balls form the distribution at the bottom
        function drawHistogram() {
            // Stats update only
        }
        
        // Chi-squared goodness of fit test
        function testBinomialFit() {
            if (totalBalls < 30) return null; // Need sufficient sample size
            
            const expectedPercents = [1.56, 9.38, 23.44, 31.25, 23.44, 9.38, 1.56];
            let chiSquared = 0;
            
            for (let i = 0; i < bins.length; i++) {
                const observed = bins[i];
                const expected = (expectedPercents[i] / 100) * totalBalls;
                if (expected > 0) {
                    chiSquared += Math.pow(observed - expected, 2) / expected;
                }
            }
            
            // Critical value for 6 degrees of freedom at 0.05 significance level
            const criticalValue = 12.592; // χ²(0.05, 6)
            
            return chiSquared <= criticalValue;
        }

        // Update statistics
        function updateStats() {
            document.getElementById('totalBalls').textContent = totalBalls;
            document.getElementById('displayBalls').textContent = totalBalls;

            // Expected percentages for 6 rows (binomial distribution with p=0.5)
            const expectedPercents = [1.56, 9.38, 23.44, 31.25, 23.44, 9.38, 1.56];

            // Test binomial fit
            const fitResult = testBinomialFit();
            const fitBadge = document.getElementById('fitBadge');
            // Update Distribution Type status
            if (totalBalls === 0) {
                fitBadge.textContent = '---';
                fitBadge.style.background = '#94a3b8';
            } else if (typeof isRunning !== 'undefined' && isRunning) {
                if (fitResult === true) {
                    fitBadge.textContent = 'Binomial';
                    fitBadge.style.background = '#10b981';
                } else {
                    fitBadge.textContent = 'calculating';
                    fitBadge.style.background = '#94a3b8';
                }
            } else {
                if (fitResult === true) {
                    fitBadge.textContent = 'Binomial';
                    fitBadge.style.background = '#10b981';
                } else if (fitResult === false) {
                    fitBadge.textContent = 'Fail';
                    fitBadge.style.background = '#ef4444';
                } else {
                    fitBadge.textContent = '---';
                    fitBadge.style.background = '#94a3b8';
                }
            }

            // Update stats panel - remove individual bin rows
            const binStats = document.getElementById('binStats');
            binStats.innerHTML = '';

            // Render frequency chart
            const freqBody = document.getElementById('freqBody');
            const freqTotalCell = document.getElementById('freqTotal');
            const relTotalCell = document.getElementById('relTotal');
            const pctTotalCell = document.getElementById('pctTotal');
            const cumPctTotalCell = document.getElementById('cumPctTotal');
            const expTotalCell = document.getElementById('expTotal');
            if (freqBody) {
                let cumulative = 0;
                let html = '';
                for (let i = 0; i < bins.length; i++) {
                    const f = bins[i];
                    const rel = totalBalls > 0 ? (f / totalBalls) : null;
                    const pct = rel != null ? (rel * 100) : null;
                    const expCount = totalBalls > 0 ? ((expectedPercents[i] / 100) * totalBalls) : null;
                    cumulative += f;
                    const cumPct = totalBalls > 0 ? (cumulative / totalBalls * 100) : null;
                    html += `<tr>` +
                            `<td style="padding:2px 0; color:#475569;">${i}</td>` +
                            `<td style="padding:2px 0; text-align:right; color:#0F172A; font-weight:600;">${f || ''}</td>` +
                            `<td style="padding:2px 0; text-align:right; color:#475569;">${rel != null ? rel.toFixed(2) : ''}</td>` +
                            `<td style="padding:2px 0; text-align:right; color:#475569;">${pct != null ? pct.toFixed(2) : ''}</td>` +
                            `<td style="padding:2px 0; text-align:right; color:#475569;">${cumPct != null ? cumPct.toFixed(2) : ''}</td>` +
                            `<td style="padding:2px 0; text-align:right; color:#475569;">${expCount != null ? expCount.toFixed(2) : ''}</td>` +
                            `</tr>`;
                }
                freqBody.innerHTML = html;
                // Totals row
                if (freqTotalCell) freqTotalCell.textContent = totalBalls || '';
                if (relTotalCell) relTotalCell.textContent = totalBalls > 0 ? '1.00' : '';
                if (pctTotalCell) pctTotalCell.textContent = totalBalls > 0 ? '100.00' : '';
                if (expTotalCell) expTotalCell.textContent = totalBalls > 0 ? totalBalls.toFixed(2) : '';
                if (cumPctTotalCell) cumPctTotalCell.textContent = totalBalls > 0 ? '100.00' : '';
            }
            
            // Update histogram
            drawHistogram();
        }

        // Reset
        async function reset() {
            if (useFirebase && db && typeof __app_id !== 'undefined') {
                // Reset Firebase counts
                const docRef = db.collection('artifacts').doc(__app_id)
                    .collection('public').doc('data')
                    .collection('plinko_stats').doc('global_tally');
                try {
                    const resetData = {};
                    for (let i = 0; i <= CONFIG.rows; i++) {
                        resetData[`bin${i}`] = 0;
                    }
                    await docRef.set(resetData);
                } catch (error) {
                    console.error('Firebase reset error:', error);
                }
                // Local mirrors
                bins = Array(CONFIG.rows + 1).fill(0);
                totalBalls = 0;
            } else {
                // Local-only reset
                bins = Array(CONFIG.rows + 1).fill(0);
                totalBalls = 0;
            }
            // Clear active and settled balls, stop animation state
            balls = [];
            settledBalls = [];
            allTrails = [];
            // Stop auto mode if running
            if (isAutoDropping || isRunning) {
                if (autoInterval) {
                    clearInterval(autoInterval);
                    autoInterval = null;
                }
                isAutoDropping = false;
                isRunning = false;
            }
            // Reset toggles to default (all off)
            TOGGLES.showTrails = false;
            TOGGLES.showBinShading = false;
            TOGGLES.showTheoretical = false;
            TOGGLES.showEmpirical = false;
            TOGGLES.showDescriptiveMarkers = false;
            CONFIG.maxBalls = 200;
            document.getElementById('toggleTrails').checked = false;
            document.getElementById('toggleBinShading').checked = false;
            document.getElementById('toggleTheoretical').checked = false;
            document.getElementById('toggleEmpirical').checked = false;
            document.getElementById('toggleDescriptiveMarkers').checked = false;
            const nbSlider = document.getElementById('numBallsSlider');
            const nbValue = document.getElementById('numBallsValue');
            if (nbSlider && nbValue) {
                nbSlider.value = 200;
                nbValue.textContent = 200;
            }
            updateStats();
        }

        // Event listeners
        let dropMode = 'auto'; // 'single' or 'auto'
        let isRunning = false;
        
        // Segmented control for drop mode
        document.querySelectorAll('#dropModeToggle .segment').forEach(btn => {
            // Make visual change instant on press (mouse & touch) with inline fallback
            btn.addEventListener('pointerdown', function(e) {
                e.preventDefault();
                document.querySelectorAll('#dropModeToggle .segment').forEach(b => {
                    b.classList.remove('active');
                    b.style.backgroundColor = '';
                    b.style.color = '';
                });
                this.classList.add('active');
                // Inline fallback to guarantee immediate visual change
                this.style.backgroundColor = '#ffffff';
                this.style.color = '#0f172a';
            });
            // Ensure active stays after press ends
            btn.addEventListener('pointerup', function() {
                this.classList.add('active');
                this.style.backgroundColor = '#ffffff';
                this.style.color = '#0f172a';
            });
            // Persist mode selection on click
            btn.addEventListener('click', function() {
                document.querySelectorAll('#dropModeToggle .segment').forEach(b => b.classList.remove('active'));
                this.classList.add('active');
                dropMode = this.dataset.mode;
                
                // Stop auto-dropping if switching to single
                if (isRunning && dropMode === 'single') {
                    isRunning = false;
                    clearInterval(autoInterval);
                }
            });
        });
        
        // Start button
        document.getElementById('startBtn').addEventListener('click', function() {
            if (dropMode === 'single') {
                addBall();
            } else {
                if (!isRunning) {
                    isRunning = true;
                    autoInterval = setInterval(addBall, 150);
                }
            }
        });
        
        // Pause button
        document.getElementById('pauseBtn').addEventListener('click', function() {
            if (isRunning) {
                isRunning = false;
                clearInterval(autoInterval);
            }
        });

        document.getElementById('reset').addEventListener('click', reset);

        document.getElementById('rowsSlider').addEventListener('input', function() {
            CONFIG.rows = parseInt(this.value);
            document.getElementById('rowsValue').textContent = this.value;
            document.getElementById('displayRows').textContent = this.value;
            initPegs();
            // Reset bins when rows change
            const newBinCount = CONFIG.rows + 1;
            bins = Array(newBinCount).fill(0);
            totalBalls = 0;
            balls = [];
            updateStats();
        });

        document.getElementById('gravitySlider').addEventListener('input', function() {
            CONFIG.gravity = parseFloat(this.value);
            const gravityValue = parseFloat(this.value).toFixed(2);
            document.getElementById('gravityValue').textContent = gravityValue;
            document.getElementById('displayGravity').textContent = gravityValue;
        });
        
        // Slow down animation for debugging
        let slowMotion = false;
        let frameSkip = 0;
        document.addEventListener('keydown', function(e) {
            if (e.key === 's' || e.key === 'S') {
                slowMotion = !slowMotion;
                console.log('Slow motion:', slowMotion ? 'ON' : 'OFF');
            }
        });

        canvas.addEventListener('click', addBall);
        
        // Download menu handlers
        const downloadMenuBtn = document.getElementById('downloadMenuBtn');
        const downloadMenu = document.getElementById('downloadMenu');
        
        downloadMenuBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            downloadMenu.style.display = downloadMenu.style.display === 'block' ? 'none' : 'block';
        });
        
        // Close menu when clicking outside
        document.addEventListener('click', function(e) {
            if (!downloadMenuBtn.contains(e.target) && !downloadMenu.contains(e.target)) {
                downloadMenu.style.display = 'none';
            }
        });
        
        // PNG download
        document.getElementById('downloadPNG').addEventListener('click', function() {
            const link = document.createElement('a');
            link.download = 'galton-board.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
            downloadMenu.style.display = 'none';
        });
        
        // PDF download
        document.getElementById('downloadPDF').addEventListener('click', function() {
            const { jsPDF } = window.jspdf;
            const pdf = new jsPDF({
                orientation: canvas.width > canvas.height ? 'landscape' : 'portrait',
                unit: 'px',
                format: [canvas.width, canvas.height]
            });
            
            const imgData = canvas.toDataURL('image/png');
            pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
            pdf.save('galton-board.pdf');
            downloadMenu.style.display = 'none';
        });
        
        // Frequency table download handlers
        const freqDownloadBtn = document.getElementById('freqDownloadBtn');
        const freqDownloadMenu = document.getElementById('freqDownloadMenu');
        
        freqDownloadBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            freqDownloadMenu.style.display = freqDownloadMenu.style.display === 'block' ? 'none' : 'block';
        });
        
        document.addEventListener('click', function(e) {
            if (!freqDownloadBtn.contains(e.target) && !freqDownloadMenu.contains(e.target)) {
                freqDownloadMenu.style.display = 'none';
            }
        });
        
        // Frequency table PNG download
        document.getElementById('freqDownloadPNG').addEventListener('click', function() {
            generateAPATable('png');
            freqDownloadMenu.style.display = 'none';
        });
        
        // Frequency table PDF download
        document.getElementById('freqDownloadPDF').addEventListener('click', function() {
            generateAPATable('pdf');
            freqDownloadMenu.style.display = 'none';
        });
        
        // Generate APA-formatted table
        function generateAPATable(format) {
            const { jsPDF } = window.jspdf;
            
            // Create APA-formatted table in a temporary container
            const container = document.createElement('div');
            container.style.cssText = 'position:absolute; left:-9999px; background:#fff; padding:40px; font-family:"Times New Roman",Times,serif;';
            
            const title = document.createElement('div');
            title.style.cssText = 'font-size:12pt; font-weight:bold; text-align:center; margin-bottom:20px;';
            title.textContent = 'Table 1';
            container.appendChild(title);
            
            const tableTitle = document.createElement('div');
            tableTitle.style.cssText = 'font-size:12pt; font-style:italic; text-align:center; margin-bottom:20px;';
            tableTitle.textContent = 'Frequency Distribution of Galton Board Simulation';
            container.appendChild(tableTitle);
            
            const table = document.createElement('table');
            table.style.cssText = 'width:100%; border-collapse:collapse; font-size:12pt;';
            
            // Header
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            headerRow.style.borderTop = '2px solid #000';
            headerRow.style.borderBottom = '1px solid #000';
            ['Bin', 'f', 'f/n', '%f', 'c.%f', 'E[f]'].forEach(h => {
                const th = document.createElement('th');
                th.style.cssText = 'padding:8px; text-align:' + (h === 'Bin' ? 'left' : 'right') + '; font-weight:normal;';
                th.innerHTML = h.includes('f') ? h.replace(/f/g, '<i>f</i>') : h.replace(/E\[(.+)\]/, 'E[<i>$1</i>]');
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);
            
            // Body
            const tbody = document.createElement('tbody');
            const freqBody = document.getElementById('freqBody');
            const rows = freqBody.querySelectorAll('tr');
            rows.forEach(row => {
                const newRow = document.createElement('tr');
                const cells = row.querySelectorAll('td');
                cells.forEach((cell, i) => {
                    const td = document.createElement('td');
                    td.style.cssText = 'padding:8px; text-align:' + (i === 0 ? 'left' : 'right') + ';';
                    td.textContent = cell.textContent;
                    newRow.appendChild(td);
                });
                tbody.appendChild(newRow);
            });
            table.appendChild(tbody);
            
            // Footer
            const tfoot = document.createElement('tfoot');
            const footerRow = document.createElement('tr');
            footerRow.style.borderTop = '1px solid #000';
            footerRow.style.borderBottom = '2px solid #000';
            ['Total', 
             document.getElementById('freqTotal').textContent,
             document.getElementById('relTotal').textContent,
             document.getElementById('pctTotal').textContent,
             document.getElementById('cumPctTotal').textContent,
             document.getElementById('expTotal').textContent
            ].forEach((text, i) => {
                const td = document.createElement('td');
                td.style.cssText = 'padding:8px; text-align:' + (i === 0 ? 'left' : 'right') + '; font-weight:' + (i <= 1 ? 'bold' : 'normal') + ';';
                td.textContent = text;
                footerRow.appendChild(td);
            });
            tfoot.appendChild(footerRow);
            table.appendChild(tfoot);
            
            container.appendChild(table);
            
            const note = document.createElement('div');
            note.style.cssText = 'font-size:10pt; margin-top:15px; text-indent:-20px; padding-left:20px;';
            note.innerHTML = '<i>Note.</i> f = frequency; f/n = relative frequency; %f = percent frequency; c.%f = cumulative percent frequency; E[f] = expected count based on binomial distribution with n = ' + totalBalls + ' and p = 0.5.';
            container.appendChild(note);
            
            document.body.appendChild(container);
            
            if (format === 'png') {
                // Use html2canvas for PNG
                html2canvas(container, { 
                    scale: 2,
                    backgroundColor: '#ffffff'
                }).then(canvas => {
                    const link = document.createElement('a');
                    link.download = 'frequency-table-apa.png';
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                    document.body.removeChild(container);
                });
            } else {
                // Use jsPDF for PDF
                html2canvas(container, { 
                    scale: 2,
                    backgroundColor: '#ffffff'
                }).then(canvas => {
                    const imgData = canvas.toDataURL('image/png');
                    const pdf = new jsPDF({
                        orientation: 'portrait',
                        unit: 'mm',
                        format: 'letter'
                    });
                    
                    const imgWidth = 170;
                    const imgHeight = (canvas.height * imgWidth) / canvas.width;
                    const x = (pdf.internal.pageSize.getWidth() - imgWidth) / 2;
                    const y = 20;
                    
                    pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);
                    pdf.save('frequency-table-apa.pdf');
                    document.body.removeChild(container);
                });
            }
        }
        
        // Visualization toggles
        document.getElementById('toggleTrails').addEventListener('change', function() {
            TOGGLES.showTrails = this.checked;
        });
        
        document.getElementById('toggleBinShading').addEventListener('change', function() {
            TOGGLES.showBinShading = this.checked;
        });
        
        document.getElementById('toggleTheoretical').addEventListener('change', function() {
            TOGGLES.showTheoretical = this.checked;
        });
        
        document.getElementById('toggleEmpirical').addEventListener('change', function() {
            TOGGLES.showEmpirical = this.checked;
        });
        
        document.getElementById('toggleDescriptiveMarkers').addEventListener('change', function() {
            TOGGLES.showDescriptiveMarkers = this.checked;
        });
        
        // Slider adjustment functions
        function adjustRows(delta) {
            const slider = document.getElementById('rowsSlider');
            const newValue = Math.max(5, Math.min(10, parseInt(slider.value) + delta));
            slider.value = newValue;
            CONFIG.rows = newValue;
            document.getElementById('rowsValue').textContent = newValue;
            document.getElementById('displayRows').textContent = newValue;
            // Reset bins when rows change
            const newBinCount = CONFIG.rows + 1;
            bins = Array(newBinCount).fill(0);
            totalBalls = 0;
            balls = [];
            updateStats();
        }
        
        function adjustGravity(delta) {
            const slider = document.getElementById('gravitySlider');
            const newValue = Math.max(0.1, Math.min(0.5, parseFloat(slider.value) + delta));
            slider.value = newValue.toFixed(2);
            CONFIG.gravity = newValue;
            const gravityValue = newValue.toFixed(2);
            document.getElementById('gravityValue').textContent = gravityValue;
            document.getElementById('displayGravity').textContent = gravityValue;
        }

        function adjustNumBalls(delta) {
            const slider = document.getElementById('numBallsSlider');
            const newValue = Math.max(1, Math.min(400, parseInt(slider.value) + delta));
            slider.value = newValue;
            CONFIG.maxBalls = newValue;
            document.getElementById('numBallsValue').textContent = newValue;
        }

        document.getElementById('numBallsSlider').addEventListener('input', function() {
            const newValue = parseInt(this.value);
            CONFIG.maxBalls = newValue;
            document.getElementById('numBallsValue').textContent = newValue;
        });
        
        // Theme selector
        document.getElementById('canvasTheme').addEventListener('change', function(e) {
            const themeName = e.target.value;
            currentTheme = THEMES[themeName];
            // Keep canvas background unified (white); theme applies to peg colors only
        });

            // Info Modal
            function initInfoModal() {
                const modal = document.getElementById('infoModal');
                const modalTitle = document.getElementById('modalTitle');
                const modalContent = document.getElementById('modalContent');
                const modalClose = modal.querySelector('.modal-close');
                const modalOverlay = modal.querySelector('.modal-overlay');
                
                function openModal(title, content) {
                    modalTitle.textContent = title;
                    // Support line breaks and basic formatting
                    const formattedContent = content.replace(/&#10;/g, '\n');
                    modalContent.style.whiteSpace = 'pre-line';
                    modalContent.textContent = formattedContent;
                    modal.classList.add('active');
                    modal.setAttribute('aria-hidden', 'false');
                    document.body.style.overflow = 'hidden';
                }
                
                function closeModal() {
                    modal.classList.remove('active');
                    modal.setAttribute('aria-hidden', 'true');
                    document.body.style.overflow = '';
                }
                
                document.querySelectorAll('.info-button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const title = button.getAttribute('data-modal-title') || 'Information';
                        const content = button.getAttribute('data-modal-content') || 'No information available.';
                        openModal(title, content);
                    });
                });
                
                if (modalClose) modalClose.addEventListener('click', closeModal);
                if (modalOverlay) modalOverlay.addEventListener('click', closeModal);
                
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && modal.classList.contains('active')) {
                        closeModal();
                    }
                });
            }

            // Initialize
            (async () => {
                useFirebase = await initFirebase();
                // Ensure canvas size matches unified layout
                canvas.width = CONFIG.width;
                canvas.height = CONFIG.height;
                // startX already set correctly in CONFIG
                // Initialize pegs
                initPegs();
                animate();
                updateStats();
                initInfoModal();
                if (useFirebase) {
                    console.log('✓ Firebase connected - stats synced globally');
                } else {
                    console.log('✓ Local mode - stats reset on refresh');
                }
            })();
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</body>
</html>
